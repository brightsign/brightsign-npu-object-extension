#!/bin/bash

# BrightSign YOLO Object Detection - Setup Script
# Creates bsoe-build Docker environment with BrightSign OS sources

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default Configuration
BRIGHTSIGN_OS_MAJOR_VERSION=${BRIGHTSIGN_OS_MAJOR_VERSION:-9.1}
BRIGHTSIGN_OS_MINOR_VERSION=${BRIGHTSIGN_OS_MINOR_VERSION:-52}

usage() {
    echo "Usage: $0 [OPTIONS]"
    echo "Setup complete BrightSign YOLO Object Detection build environment with RKNN toolkit, models, and containers"
    echo ""
    echo "Options:"
    echo "  -y, --yes              Skip confirmation prompt"
    echo "  --force-download       Force re-download of models even if they exist"
    echo "  -v, --version VERSION  Set BrightSign OS version (e.g., 9.1.52)"
    echo "  --major VERSION        Set major.minor version (e.g., 9.1)"
    echo "  --minor VERSION        Set minor version number (e.g., 52)"
    echo "  -h, --help             Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                     # Interactive setup with default version"
    echo "  $0 -y                  # Automatic setup, no prompts"
    echo "  $0 -v 9.1.53           # Setup with specific OS version"
    echo ""
    echo "Default BrightSign OS version: ${BRIGHTSIGN_OS_MAJOR_VERSION}.${BRIGHTSIGN_OS_MINOR_VERSION}"
}

# Parse command line arguments
AUTO_YES=false
FORCE_DOWNLOAD=false
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -y|--yes) AUTO_YES=true; shift ;;
        --force-download) FORCE_DOWNLOAD=true; shift ;;
        -v|--version) 
            if [[ $2 =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                BRIGHTSIGN_OS_MAJOR_VERSION="${2%.*}"
                BRIGHTSIGN_OS_MINOR_VERSION="${2##*.}"
            elif [[ $2 =~ ^[0-9]+\.[0-9]+$ ]]; then
                BRIGHTSIGN_OS_MAJOR_VERSION="$2"
                BRIGHTSIGN_OS_MINOR_VERSION="0"
            else
                echo "Invalid version format: $2. Use major.minor or major.minor.patch"
                exit 1
            fi
            shift 2 ;;
        --major) 
            BRIGHTSIGN_OS_MAJOR_VERSION="$2"; shift 2 ;;
        --minor) 
            BRIGHTSIGN_OS_MINOR_VERSION="$2"; shift 2 ;;
        -h|--help)
            usage
            exit 0
            ;;
        *) echo "Unknown parameter: $1"; usage; exit 1 ;;
    esac
done

# Set the full version string
BRIGHTSIGN_OS_VERSION=${BRIGHTSIGN_OS_MAJOR_VERSION}.${BRIGHTSIGN_OS_MINOR_VERSION}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date +'%T')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

error() {
    echo -e "${RED}❌ $1${NC}"
    exit 1
}

success() {
    echo -e "${GREEN}✅ $1${NC}"
}

# Check if a model file exists and is valid
check_model_file() {
    local file_path="$1"
    local min_size_mb="${2:-1}"  # Default minimum size: 1MB
    
    if [[ ! -f "$file_path" ]]; then
        return 1  # File doesn't exist
    fi
    
    # Check file size (in MB)
    local file_size=$(stat -c%s "$file_path" 2>/dev/null || stat -f%z "$file_path" 2>/dev/null)
    local min_size_bytes=$((min_size_mb * 1024 * 1024))
    
    if [[ -z "$file_size" ]] || [[ "$file_size" -lt "$min_size_bytes" ]]; then
        warn "Model file $file_path exists but appears incomplete (size: ${file_size:-0} bytes)"
        return 1  # File is too small
    fi
    
    return 0  # File exists and appears valid
}

# Check for schema updates
check_schema_version() {
    log "Checking extension manifest schema version..."
    
    local schema_url="https://brightsign.biz/schemas/extension-manifest/v1.json"
    local local_schema="schemas/extension-manifest-v1.json"
    
    # Check if local schema exists
    if [[ ! -f "$local_schema" ]]; then
        warn "Local schema file not found at $local_schema"
        return 0
    fi
    
    # Try to fetch remote schema (with timeout)
    if command -v curl >/dev/null 2>&1; then
        log "Checking for schema updates (5 second timeout)..."
        if curl -s --connect-timeout 5 --max-time 10 "$schema_url" > /tmp/remote_schema.json 2>/dev/null && [[ -s /tmp/remote_schema.json ]]; then
            # Extract schema identifiers (using $id field which is more reliable than $schema)
            local local_version=$(jq -r '.["$id"] // .version // "unknown"' "$local_schema" 2>/dev/null || echo "unknown")
            local remote_version=$(jq -r '.["$id"] // .version // "unknown"' /tmp/remote_schema.json 2>/dev/null || echo "unknown")
            
            # Only compare if we can determine versions
            if [[ "$local_version" == "unknown" && "$remote_version" == "unknown" ]]; then
                log "Schema versions could not be determined, skipping comparison"
            elif [[ "$local_version" == "unknown" ]]; then
                warn "Local schema version unknown, remote version: $remote_version"
            elif [[ "$remote_version" == "unknown" ]]; then
                log "Remote schema version unknown, using local version: $local_version"
            elif [[ "$local_version" != "$remote_version" ]]; then
                warn "Different schema version available online"
                warn "Local:  $local_version"
                warn "Remote: $remote_version"
                warn "Consider updating your local schema before packaging extensions"
                echo ""
            elif ! diff -q "$local_schema" /tmp/remote_schema.json >/dev/null 2>&1; then
                log "Schema version unchanged ($local_version) but content differs - minor updates available"
            else
                log "Schema is up to date ($local_version)"
            fi
            rm -f /tmp/remote_schema.json
        else
            log "Could not fetch remote schema (offline, timeout, or empty response)"
        fi
    else
        log "curl not available, skipping schema update check"
    fi
}

# Prerequisites check
check_prerequisites() {
    log "Checking prerequisites..."
    
    # Check architecture
    if [[ "$(uname -m)" != "x86_64" ]]; then
        error "This build requires x86_64 architecture. Current: $(uname -m)"
    fi
    
    # Check Docker
    if ! command -v docker &> /dev/null; then
        error "Docker is required but not installed. Please install Docker first."
    fi
    
    # Check Docker daemon
    if ! docker info &> /dev/null; then
        error "Docker daemon is not running. Please start Docker."
    fi
    
    # Check required tools
    for tool in wget tar git cmake; do
        if ! command -v $tool &> /dev/null; then
            error "$tool is required but not installed."
        fi
    done
    
    # Check disk space (need ~25GB)
    available_space=$(df . | awk 'NR==2 {print $4}')
    required_space=$((25 * 1024 * 1024)) # 25GB in KB
    
    if [[ $available_space -lt $required_space ]]; then
        warn "Warning: Less than 25GB free space available. Build may fail."
        warn "Available: $(($available_space / 1024 / 1024))GB, Recommended: 25GB+"
    fi
    
    success "Prerequisites check passed"
}

# Setup Docker build environment
setup_docker() {
    log "Setting up Docker build environment..."
    
    # Build Docker image with BrightSign OS sources downloaded inside container
    log "Building Docker image (this may take 5-60 minutes depending on download speed)..."
    log "This will download BrightSign OS source (~20GB) inside the container"
    docker build --rm \
        --build-arg USER_ID=$(id -u) \
        --build-arg GROUP_ID=$(id -g) \
        --build-arg BRIGHTSIGN_OS_VERSION=${BRIGHTSIGN_OS_VERSION} \
        --ulimit memlock=-1:-1 \
        -t bsoe-build . || error "Failed to build Docker image"
    
    # Create srv directory for build outputs
    mkdir -p srv
    
    success "Docker environment ready"
}

# Clone or update RKNN toolkit and download models
clone_rknn_toolkit() {
    log "Setting up RKNN toolkit and model zoo..."
    
    # Always start from script directory
    cd "${SCRIPT_DIR}"
    
    # Create toolkit directory if it doesn't exist
    mkdir -p toolkit
    
    # Clone or update rknn-toolkit2
    cd "${SCRIPT_DIR}"
    if [[ -d "toolkit/rknn-toolkit2" ]]; then
        log "rknn-toolkit2 already exists, updating..."
        pushd toolkit/rknn-toolkit2 > /dev/null
        git fetch || warn "Failed to fetch updates"
        git checkout v2.3.0 || warn "Failed to checkout v2.3.0 tag"
        popd > /dev/null
    else
        log "Cloning rknn-toolkit2..."
        pushd toolkit > /dev/null
        git clone https://github.com/airockchip/rknn-toolkit2.git --depth 1 --branch v2.3.0 || error "Failed to clone rknn-toolkit2"
        popd > /dev/null
    fi
    
    # Clone or update rknn_model_zoo
    cd "${SCRIPT_DIR}"
    if [[ -d "toolkit/rknn_model_zoo" ]]; then
        log "rknn_model_zoo already exists, updating..."
        pushd toolkit/rknn_model_zoo > /dev/null
        git fetch || warn "Failed to fetch updates"
        git checkout v2.3.0 || warn "Failed to checkout v2.3.0 tag"
        popd > /dev/null
    else
        log "Cloning rknn_model_zoo..."
        pushd toolkit > /dev/null
        git clone https://github.com/airockchip/rknn_model_zoo.git --depth 1 --branch v2.3.0 || error "Failed to clone rknn_model_zoo"
        popd > /dev/null
    fi
    
    # Download ONNX models
    log "Downloading ONNX models..."
    
    # Download YOLO Simplified model
    cd "${SCRIPT_DIR}"
    log "Checking YOLOv8 model..."
    mkdir -p toolkit/rknn_model_zoo/examples/yolov8/model/RK3588
    if [[ -d "toolkit/rknn_model_zoo/examples/yolov8/model" ]]; then
        pushd toolkit/rknn_model_zoo/examples/yolov8/model > /dev/null
        
        # Check if model already exists and is valid
        if check_model_file "yolov8n.onnx" 10 && [[ "$FORCE_DOWNLOAD" != true ]]; then
            log "YOLOv8 model already exists ($(stat -c%s yolov8n.onnx 2>/dev/null || stat -f%z yolov8n.onnx 2>/dev/null | numfmt --to=iec-i --suffix=B 2>/dev/null || echo 'size unknown')), skipping download"
        else
            if [[ "$FORCE_DOWNLOAD" == true ]]; then
                log "Force downloading YOLOv8 model..."
            else
                log "Downloading YOLOv8 model..."
            fi
            
            if [[ -f "download_model.sh" ]]; then
                chmod +x ./download_model.sh
                ./download_model.sh || warn "Failed to download YOLOv8 model"
            else
                warn "YOLOv8 download_model.sh not found"
            fi
        fi
        
        popd > /dev/null
    fi
    
    # Download YOLOX model  
    cd "${SCRIPT_DIR}"
    log "Checking YOLOX model..."
    mkdir -p toolkit/rknn_model_zoo/examples/yolox/model/RK3588
    if [[ -d "toolkit/rknn_model_zoo/examples/yolox/model" ]]; then
        pushd toolkit/rknn_model_zoo/examples/yolox/model > /dev/null
        
        # Check if model already exists and is valid
        if check_model_file "yolox_s.onnx" 10 && [[ "$FORCE_DOWNLOAD" != true ]]; then
            log "YOLOX model already exists ($(stat -c%s yolox_s.onnx 2>/dev/null || stat -f%z yolox_s.onnx 2>/dev/null | numfmt --to=iec-i --suffix=B 2>/dev/null || echo 'size unknown')), skipping download"
        else
            if [[ "$FORCE_DOWNLOAD" == true ]]; then
                log "Force downloading YOLOX model..."
            else
                log "Downloading YOLOX model..."
            fi
            
            if [[ -f "download_model.sh" ]]; then
                chmod +x ./download_model.sh
                ./download_model.sh || warn "Failed to download YOLOX model"
            else
                warn "YOLOX download_model.sh not found"
            fi
        fi
        
        popd > /dev/null
    fi
    
    # Build rknn_tk2 Docker container
    cd "${SCRIPT_DIR}"
    log "Building rknn_tk2 Docker container..."
    if [[ -d "toolkit/rknn-toolkit2/rknn-toolkit2/docker/docker_file/ubuntu_20_04_cp38" ]]; then
        pushd toolkit/rknn-toolkit2/rknn-toolkit2/docker/docker_file/ubuntu_20_04_cp38 > /dev/null
        if docker build --rm -t rknn_tk2 -f Dockerfile_ubuntu_20_04_for_cp38 .; then
            success "rknn_tk2 Docker container built successfully"
        else
            warn "Failed to build rknn_tk2 Docker container - you may need to build it manually"
        fi
        popd > /dev/null
    else
        warn "Docker build directory not found at toolkit/rknn-toolkit2/rknn-toolkit2/docker/docker_file/ubuntu_20_04_cp38"
    fi
    
    # Ensure we're back at script directory
    cd "${SCRIPT_DIR}"
    
    success "RKNN toolkit, model zoo, ONNX models, and Docker container ready"
}

# Main setup function
main() {
    echo "BrightSign YOLO Object Detection - Setup Script"
    echo "==============================================="
    echo "This script will:"
    echo "1. Check prerequisites"
    echo "2. Clone RKNN toolkit and model zoo repositories"
    echo "3. Download ONNX models (YOLOv8n, YOLOX-s) if not present"
    echo "4. Build rknn_tk2 Docker container for model compilation"
    echo "5. Setup Docker build environment (bsoe-build)"
    echo "6. Download BrightSign OS source (~20GB) inside Docker container"
    echo ""
    echo "Building for BrightSign OS version: ${BRIGHTSIGN_OS_VERSION}"
    echo ""
    
    # Confirm execution if AUTO_YES is not set
    if [[ "$AUTO_YES" != true ]]; then
        read -p "Continue? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Setup cancelled."
            exit 0
        fi
    else
        log "Automatic mode: skipping confirmation prompt"
    fi
    
    start_time=$(date +%s)
    
    check_prerequisites
    check_schema_version
    clone_rknn_toolkit
    setup_docker
    
    end_time=$(date +%s)
    duration=$((end_time - start_time))
    
    echo ""
    success "Setup completed successfully in $(($duration / 60))m $(($duration % 60))s"
    echo ""
    echo "Next steps:"
    echo "1. Run './compile-models' to compile ONNX models to RKNN format"
    echo "2. Run './build --extract-sdk' to build SDK and extract it"
    echo "3. Run './brightsign-x86*.sh -d ./sdk -y' to install SDK"
    echo "4. Run './build-apps' to build C++ application for all platforms"
    echo ""
    echo "Environment variables set:"
    echo "export BRIGHTSIGN_OS_VERSION=${BRIGHTSIGN_OS_VERSION}"
    echo "export PROJECT_ROOT=$(pwd)"
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi