#!/bin/bash

# BrightSign YOLO Object Detection - Package Creation Script
# Creates both development and extension packages with multi-SOC support

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Cleanup on exit
cleanup_on_exit() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        echo ""
        warn "Script failed with exit code $exit_code"
        warn "Staging directory preserved for debugging: staging/"
    fi
}

# Set trap for cleanup on script exit
trap cleanup_on_exit EXIT

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[PACKAGE] $1${NC}"
}

warn() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

error() {
    echo -e "${RED}âŒ $1${NC}"
    exit 1
}

success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

# Configuration
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
DEVELOPMENT_PACKAGE="yolo-dev-${TIMESTAMP}.zip"
EXTENSION_PACKAGE="yolo-ext-${TIMESTAMP}.zip"

# Supported SOCs and their mappings
declare -A SOC_PLATFORMS=(
    ["RK3588"]="XT5"
    ["RK3576"]="Firebird" 
    ["RK3568"]="LS5"
)

usage() {
    echo "Usage: $0 [OPTIONS]"
    echo "Package BrightSign YOLO Object Detection extension for deployment"
    echo ""
    echo "Options:"
    echo "  -d, --dev-only     Create development package only"
    echo "  -e, --ext-only     Create extension package only"
    echo "  -c, --clean        Clean install directory before packaging"
    echo "  -v, --verify       Run validation after packaging"
    echo "  --soc SOC          Package specific SOC only (RK3588, RK3576, RK3568)"
    echo "  --model MODEL      Include specific model only (yolov8, yolox, all)"
    echo "  -h, --help         Show this help message"
    echo ""
    echo "Package types:"
    echo "  Development: For /usr/local deployment (volatile, testing)"
    echo "  Extension:   For permanent installation (production)"
    echo ""
    echo "SOC Support:"
    echo "  RK3588  -> XT-5 players (XT1145, XT2145)"
    echo "  RK3576  -> Firebird development boards"
    echo "  RK3568  -> LS-5 players (LS445)"
    echo ""
    echo "Model Support:"
    echo "  yolov8  -> YOLOv8 nano model (YOLO Simplified)"
    echo "  yolox   -> YOLOX small model"
    echo "  all     -> Both models (default)"
}

# Parse command line arguments
DEV_ONLY=false
EXT_ONLY=false
CLEAN=false
VERIFY=false
SPECIFIC_SOC=""
SPECIFIC_MODEL="all"

while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--dev-only)
            DEV_ONLY=true
            shift
            ;;
        -e|--ext-only)
            EXT_ONLY=true
            shift
            ;;
        -c|--clean)
            CLEAN=true
            shift
            ;;
        -v|--verify)
            VERIFY=true
            shift
            ;;
        --soc)
            SPECIFIC_SOC="$2"
            if [[ ! "${SPECIFIC_SOC}" =~ ^(RK3588|RK3576|RK3568)$ ]]; then
                error "Invalid SOC: $SPECIFIC_SOC. Must be RK3588, RK3576, or RK3568"
            fi
            shift 2
            ;;
        --model)
            SPECIFIC_MODEL="$2"
            if [[ ! "${SPECIFIC_MODEL}" =~ ^(yolov8|yolox|all)$ ]]; then
                error "Invalid model: $SPECIFIC_MODEL. Must be yolov8, yolox, or all"
            fi
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Check prerequisites
check_prerequisites() {
    log "Checking prerequisites..."

    # Check for compiled binaries
    local found_binaries=false
    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local build_dir="build_${SOC_PLATFORMS[$soc],,}"
        if [[ -f "$build_dir/yolo_demo" ]]; then
            found_binaries=true
            break
        fi
    done

    if [[ "$found_binaries" != "true" ]]; then
        error "No compiled binaries found. Please run './build-apps' first."
    fi

    # Check for compiled models
    local found_models=false
    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local install_dir="install/$soc"
        if [[ -d "$install_dir/model" ]]; then
            if [[ "$SPECIFIC_MODEL" == "all" || "$SPECIFIC_MODEL" == "yolov8" ]] && [[ -f "$install_dir/model/yolov8n.rknn" ]]; then
                found_models=true
                break
            fi
            if [[ "$SPECIFIC_MODEL" == "all" || "$SPECIFIC_MODEL" == "yolox" ]] && [[ -f "$install_dir/model/yolox_s.rknn" ]]; then
                found_models=true
                break
            fi
        fi
    done

    if [[ "$found_models" != "true" ]]; then
        error "No compiled models found. Please run './compile-models' first."
    fi

    # Check for required scripts
    if [[ ! -f "sh/make-extension-lvm" ]]; then
        error "make-extension-lvm script not found"
    fi

    if [[ ! -f "bsext_init" ]]; then
        error "bsext_init script not found"
    fi

    success "Prerequisites check passed"
}

# Create package directory structure
create_package_structure() {
    log "Creating package structure..."

    if [[ "$CLEAN" == "true" ]]; then
        log "Cleaning existing staging directory..."
        rm -rf staging
    fi

    # Create base package structure
    mkdir -p staging

    # Create SOC-specific directories
    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local platform="${SOC_PLATFORMS[$soc]}"
        log "Creating directory structure for $soc ($platform)..."
        mkdir -p "staging/$soc"
    done

    success "Package structure created"
}

# Copy binaries and libraries for each SOC
copy_binaries() {
    log "Copying compiled binaries and libraries..."

    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local platform="${SOC_PLATFORMS[$soc]}"
        local build_dir="build_${platform,,}"
        local package_soc_dir="staging/$soc"
        
        log "Copying $soc ($platform) binaries from $build_dir..."
        
        if [[ ! -d "$build_dir" ]]; then
            warn "Build directory $build_dir not found, skipping $soc"
            continue
        fi

        # Copy main binary
        if [[ -f "$build_dir/yolo_demo" ]]; then
            cp "$build_dir/yolo_demo" "$package_soc_dir/"
            chmod +x "$package_soc_dir/yolo_demo"
        else
            warn "Binary not found in $build_dir, skipping $soc"
            continue
        fi

        # Copy libraries
        mkdir -p "$package_soc_dir/lib"
        
        # Copy shared libraries from build directory
        for lib in "$build_dir"/*.so*; do
            if [[ -f "$lib" ]]; then
                cp "$lib" "$package_soc_dir/lib/"
            fi
        done

        success "$soc binaries copied"
    done
}

# Copy models for each SOC
copy_models() {
    log "Copying compiled models..."

    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local platform="${SOC_PLATFORMS[$soc]}"
        local install_dir="install/$soc"
        local package_soc_dir="staging/$soc"
        
        log "Copying $soc ($platform) models from $install_dir..."
        
        if [[ ! -d "$install_dir/model" ]]; then
            warn "Model directory $install_dir/model not found, skipping $soc models"
            continue
        fi

        mkdir -p "$package_soc_dir/model"

        # Copy models based on selection
        if [[ "$SPECIFIC_MODEL" == "all" || "$SPECIFIC_MODEL" == "yolov8" ]]; then
            if [[ -f "$install_dir/model/yolov8n.rknn" ]]; then
                cp "$install_dir/model/yolov8n.rknn" "$package_soc_dir/model/"
                log "Copied YOLOv8 model for $soc"
            fi
        fi

        if [[ "$SPECIFIC_MODEL" == "all" || "$SPECIFIC_MODEL" == "yolox" ]]; then
            if [[ -f "$install_dir/model/yolox_s.rknn" ]]; then
                cp "$install_dir/model/yolox_s.rknn" "$package_soc_dir/model/"
                log "Copied YOLOX model for $soc"
            fi
        fi

        # Always copy labels file
        if [[ -f "$install_dir/model/coco_80_labels_list.txt" ]]; then
            cp "$install_dir/model/coco_80_labels_list.txt" "$package_soc_dir/model/"
        fi

        success "$soc models copied"
    done
}

# Generate manifest.json from manifest-config.json
generate_manifest() {
    log "Generating manifest.json..."
    
    # Check if manifest-config.json exists
    if [[ ! -f "manifest-config.json" ]]; then
        warn "manifest-config.json not found. Creating from template..."
        if [[ -f "manifest-config.template.json" ]]; then
            cp manifest-config.template.json manifest-config.json
            warn "Please edit manifest-config.json with your extension information"
        else
            error "manifest-config.json and template not found"
        fi
    fi
    
    # Read configuration
    local config_content=$(cat manifest-config.json)
    
    # Get build information
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
    local sdk_version="unknown"
    
    # Try to determine SDK version from environment or installed SDK
    if [[ -n "${OECORE_SDK_VERSION}" ]]; then
        sdk_version="brightsign-sdk-${OECORE_SDK_VERSION}"
    elif [[ -f "sdk/version-*" ]]; then
        sdk_version=$(basename sdk/version-* | sed 's/version-/brightsign-sdk-/')
    fi
    
    # Determine which SOCs are being packaged
    local soc_array="[]"
    local soc_json_items=()
    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local platform="${SOC_PLATFORMS[$soc]}"
        if [[ -d "staging/$soc" ]]; then
            local experimental="false"
            if [[ "$soc" == "RK3576" ]]; then
                experimental="true"
            fi
            soc_json_items+=("    {\"id\": \"$soc\", \"platforms\": [\"$platform\"], \"minRevision\": \"1.0\", \"experimental\": $experimental}")
        fi
    done
    
    if [[ ${#soc_json_items[@]} -gt 0 ]]; then
        soc_array="[
"
        soc_array+=$(printf '%s,\n' "${soc_json_items[@]}" | sed '$ s/,$//')
        soc_array+="
  ]"
    fi
    
    # Determine player compatibility based on SOCs
    local players_array="[]"
    if [[ "$soc_array" != "[]" ]]; then
        local player_items=()
        
        # RK3588 -> Series 5 XT players
        if [[ "$soc_array" =~ "RK3588" ]]; then
            player_items+=("    {\"series\": \"5\", \"models\": [\"XT1145\", \"XT2145\"], \"features\": [\"npu\"]}")
        fi
        
        # RK3568 -> Series 5 LS players  
        if [[ "$soc_array" =~ "RK3568" ]]; then
            player_items+=("    {\"series\": \"5\", \"models\": [\"LS445\"], \"features\": [\"npu\"]}")
        fi
        
        # RK3576 -> Firebird development boards
        if [[ "$soc_array" =~ "RK3576" ]]; then
            player_items+=("    {\"series\": \"firebird\", \"models\": [\"dev\"], \"features\": [\"npu\"], \"experimental\": true}")
        fi
        
        if [[ ${#player_items[@]} -gt 0 ]]; then
            players_array="[
"
            players_array+=$(printf '%s,\n' "${player_items[@]}" | sed '$ s/,$//')
            players_array+="
  ]"
        fi
    fi
    
    # Extract key fields from config using jq
    local version=$(echo "$config_content" | jq -r '.extension.version // "1.0.0"')
    local description=$(echo "$config_content" | jq -r '.extension.description // "BrightSign Extension"')
    local author=$(echo "$config_content" | jq -c '.extension.author // {"name": "Unknown"}')
    local license=$(echo "$config_content" | jq -r '.extension.license // "Proprietary"')
    local homepage=$(echo "$config_content" | jq -r '.extension.homepage // ""')
    local category=$(echo "$config_content" | jq -r '.extension.category // "utility"')
    
    # Extract compatibility info
    local os_min=$(echo "$config_content" | jq -r '.compatibility.osVersion.min // "9.0.0"')
    local os_target=$(echo "$config_content" | jq -r '.compatibility.osVersion.target // "9.1.0"')
    local os_max=$(echo "$config_content" | jq -r '.compatibility.osVersion.max // null')
    
    # Build OS version object
    local os_version_obj="{\"min\": \"$os_min\", \"target\": \"$os_target\""
    if [[ "$os_max" != "null" ]]; then
        os_version_obj+=", \"max\": \"$os_max\""
    fi
    os_version_obj+="}"
    
    # Extract other sections
    local requirements=$(echo "$config_content" | jq -c '.requirements // {}')
    local runtime=$(echo "$config_content" | jq -c '.runtime // {}')
    local registry=$(echo "$config_content" | jq -c '.registry // {}')
    local update=$(echo "$config_content" | jq -c '.update // {}')
    
    # Build the manifest JSON
    cat > staging/manifest.json <<EOF
{
  "\$schema": "https://brightsign.biz/schemas/extension-manifest/v1.json",
  "manifestVersion": 1,
  
  "extension": {
    "id": "com.brightsign.yolo-object-detection",
    "name": "YOLO Object Detection",
    "shortName": "YOLO",
    "version": "$version",
    "description": "$description",
    "author": $author,
    "license": "$license",
    "homepage": "$homepage",
    "category": "$category"
  },
  
  "compatibility": {
    "osVersion": $os_version_obj,
    "players": $players_array,
    "soc": $soc_array
  },
  
  "requirements": $requirements,
  
  "runtime": $runtime,
  
  "registry": $registry,
  
  "update": $update,
  
  "build": {
    "timestamp": "$timestamp",
    "sdk": "$sdk_version",
    "commit": "$commit_hash"
  }
}
EOF

    # Validate the generated manifest
    if command -v jq >/dev/null 2>&1; then
        if jq empty staging/manifest.json 2>/dev/null; then
            success "manifest.json generated and validated"
        else
            error "Generated manifest.json is not valid JSON"
        fi
    else
        warn "jq not installed, skipping manifest validation"
        success "manifest.json generated"
    fi
}

# Add extension management scripts
copy_extension_scripts() {
    log "Adding extension management scripts..."

    # Copy main bsext_init script
    cp bsext_init staging/ && chmod +x staging/bsext_init

    # Copy uninstall script
    if [[ -f "sh/uninstall.sh" ]]; then
        cp sh/uninstall.sh staging/ && chmod +x staging/uninstall.sh
    fi

    # Copy schema file for offline validation
    if [[ -f "schemas/extension-manifest-v1.json" ]]; then
        mkdir -p staging/schemas
        cp schemas/extension-manifest-v1.json staging/schemas/
        log "Schema file bundled for offline validation"
    else
        warn "Schema file not found, skipping schema bundling"
    fi

    success "Extension scripts added"
}

# Verify package structure
verify_package() {
    log "Verifying package structure... in $(pwd)"
    
    local errors=0
    local total_files=0

    # Check for main scripts
    local essential_files=(
        "bsext_init"
        "uninstall.sh"
        "manifest.json"
        "schemas/extension-manifest-v1.json"
    )

    for file in "${essential_files[@]}"; do
        log "Checking file: $file"
        echo "$file: $(ls -l staging/$file 2>/dev/null || echo "File not found")"
        if [[ ! -f "staging/$file" ]]; then
            warn "Missing file: staging/$file (pwd: $(pwd))"
            errors=$((errors + 1))
        else
            log "Found file: staging/$file"
        fi
    done

    # Check SOC directories
    log "Checking SOC directories..."
    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local platform="${SOC_PLATFORMS[$soc]}"
        local soc_dir="staging/$soc"
        log "Checking SOC directory: $soc_dir"
        
        if [[ ! -d "$soc_dir" ]]; then
            warn "Missing SOC directory: $soc_dir"
            ((errors++)) || true
            continue
        fi

        # Check for binary
        if [[ ! -f "$soc_dir/yolo_demo" ]]; then
            warn "Missing binary: $soc_dir/yolo_demo"
            errors=$((errors + 1))
        else
            total_files=$((total_files + 1))
        fi

        # Check for models
        local models_found=0
        if [[ "$SPECIFIC_MODEL" == "all" || "$SPECIFIC_MODEL" == "yolov8" ]] && [[ -f "$soc_dir/model/yolov8n.rknn" ]]; then
            models_found=$((models_found + 1))
            total_files=$((total_files + 1))
        fi
        if [[ "$SPECIFIC_MODEL" == "all" || "$SPECIFIC_MODEL" == "yolox" ]] && [[ -f "$soc_dir/model/yolox_s.rknn" ]]; then
            models_found=$((models_found + 1))
            total_files=$((total_files + 1))
        fi

        if [[ $models_found -eq 0 ]]; then
            warn "No models found for $soc in $soc_dir/model/"
            errors=$((errors + 1))
        fi

        log "$soc ($platform): Binary + $models_found models"
    done
    
    log "Completed SOC directory checks"

    echo "Check errors: $errors"
    echo "Total files packaged: $total_files"
    if [[ $errors -eq 0 ]]; then
        success "Package verification passed ($total_files files packaged)"
    else
        warn "Package verification found $errors issues"
    fi

    # Show package size
    local package_size=$(du -sh staging/ 2>/dev/null | cut -f1)
    log "Package size: $package_size"
}

# Enhanced host-side validation for Phase 3
validate_manifest_schema() {
    log "Validating manifest.json schema..."
    
    local manifest_file="staging/manifest.json"
    local schema_file="schemas/extension-manifest-v1.json"
    
    if [[ ! -f "$manifest_file" ]]; then
        error "manifest.json not found in staging directory"
        return 1
    fi
    
    # Basic JSON syntax validation
    if ! jq empty "$manifest_file" 2>/dev/null; then
        error "manifest.json contains invalid JSON syntax"
        return 1
    fi
    
    # Schema validation if available
    if [[ -f "$schema_file" ]] && command -v jq >/dev/null 2>&1; then
        # Note: jq doesn't have built-in JSON schema validation
        # For now, we'll do basic structural validation
        local required_fields=("manifestVersion" "extension" "compatibility")
        
        for field in "${required_fields[@]}"; do
            if [[ $(jq -r ".$field // empty" "$manifest_file") == "" ]]; then
                error "Required field missing in manifest.json: $field"
                return 1
            fi
        done
        
        success "Manifest schema validation passed"
    else
        warn "Schema validation skipped (schema file or jq not available)"
    fi
    
    return 0
}

# Validate package size against storage requirements
validate_package_size() {
    log "Validating package size against requirements..."
    
    local manifest_file="staging/manifest.json"
    
    if [[ ! -f "$manifest_file" ]]; then
        warn "No manifest.json found, skipping size validation"
        return 0
    fi
    
    # Get declared installation size requirement
    local declared_size=$(jq -r '.requirements.storage.installation // "unknown"' "$manifest_file" 2>/dev/null)
    
    if [[ "$declared_size" == "unknown" || "$declared_size" == "null" ]]; then
        warn "No installation size declared in manifest, skipping size validation"
        return 0
    fi
    
    # Calculate actual package size in bytes
    local actual_size_kb=$(du -sk staging/ | cut -f1)
    local actual_size_mb=$((actual_size_kb / 1024))
    
    # Parse declared size (assumes format like "150MB")
    local declared_size_num=$(echo "$declared_size" | sed 's/[^0-9]//g')
    local declared_size_unit=$(echo "$declared_size" | sed 's/[0-9]//g')
    
    # Convert declared size to MB for comparison
    local declared_size_mb="$declared_size_num"
    if [[ "$declared_size_unit" == "GB" ]]; then
        declared_size_mb=$((declared_size_num * 1024))
    elif [[ "$declared_size_unit" == "KB" ]]; then
        declared_size_mb=$((declared_size_num / 1024))
    fi
    
    # Check if actual size exceeds declared size by more than 10%
    local size_limit=$((declared_size_mb * 110 / 100))  # 10% tolerance
    
    if [[ $actual_size_mb -gt $size_limit ]]; then
        warn "Package size (${actual_size_mb}MB) exceeds declared requirement (${declared_size}) by >10%"
        warn "Consider updating manifest.json storage requirements or reducing package size"
    else
        success "Package size validation passed (${actual_size_mb}MB <= ${declared_size})"
    fi
    
    return 0
}

# Validate cross-platform consistency
validate_platform_consistency() {
    log "Validating cross-platform consistency..."
    
    local errors=0
    
    # Check that all expected SOCs have binaries and models
    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local soc_dir="staging/$soc"
        if [[ ! -d "$soc_dir" ]]; then
            continue  # Skip if SOC directory doesn't exist
        fi
        
        # Validate binary exists and is executable
        if [[ ! -f "$soc_dir/yolo_demo" ]]; then
            warn "Missing binary for $soc: $soc_dir/yolo_demo"
            ((errors++))
        elif [[ ! -x "$soc_dir/yolo_demo" ]]; then
            warn "Binary not executable for $soc: $soc_dir/yolo_demo"
            ((errors++))
        fi
        
        # Validate model consistency across platforms
        local expected_models=()
        if [[ "$SPECIFIC_MODEL" == "all" || "$SPECIFIC_MODEL" == "yolov8" ]]; then
            expected_models+=("yolov8n.rknn")
        fi
        if [[ "$SPECIFIC_MODEL" == "all" || "$SPECIFIC_MODEL" == "yolox" ]]; then
            expected_models+=("yolox_s.rknn")
        fi
        
        for model in "${expected_models[@]}"; do
            if [[ ! -f "$soc_dir/model/$model" ]]; then
                warn "Missing model for $soc: $soc_dir/model/$model"
                ((errors++))
            fi
        done
    done
    
    if [[ $errors -eq 0 ]]; then
        success "Platform consistency validation passed"
    else
        warn "Platform consistency validation found $errors issues"
    fi
    
    return $errors
}

# Enhanced validation combining all checks
enhanced_validation() {
    log "Running enhanced Phase 3 validation..."
    
    local total_errors=0
    
    # Schema validation
    validate_manifest_schema
    total_errors=$((total_errors + $?))
    
    # Size validation  
    validate_package_size
    total_errors=$((total_errors + $?))
    
    # Platform consistency validation
    validate_platform_consistency
    total_errors=$((total_errors + $?))
    
    # Existing package structure validation
    verify_package
    # Note: verify_package doesn't return error codes, so we don't add to total_errors
    
    if [[ $total_errors -eq 0 ]]; then
        success "All enhanced validations passed"
    else
        warn "Enhanced validation completed with $total_errors errors/warnings"
        warn "Review issues above before deploying to production"
    fi
    
    return $total_errors
}

# Create development package
create_development_package() {
    log "Creating development package..."

    cd staging
    zip -r "../$DEVELOPMENT_PACKAGE" ./ >/dev/null
    cd ..

    local package_size=$(du -sh "$DEVELOPMENT_PACKAGE" 2>/dev/null | cut -f1)
    success "Development package created: $DEVELOPMENT_PACKAGE ($package_size)"

    echo ""
    echo "Development Package Usage:"
    echo "1. Transfer $DEVELOPMENT_PACKAGE to player via DWS"
    echo "2. On player: mkdir -p /usr/local/yolo && cd /usr/local/yolo"
    echo "3. On player: unzip /storage/sd/$DEVELOPMENT_PACKAGE"
    echo "4. On player: ./bsext_init run"
    echo "Note: Development installation is volatile (lost on reboot)"
}

# Create extension package
create_extension_package() {
    log "Creating production extension package..."

    cd staging

    # Run make-extension script
    ../sh/make-extension-lvm || error "Extension creation failed"

    # Package the extension
    zip "../$EXTENSION_PACKAGE" ext_npu_yolo* >/dev/null

    # Clean up temporary files
    rm -rf ext_npu_yolo*

    cd ..

    local package_size=$(du -sh "$EXTENSION_PACKAGE" 2>/dev/null | cut -f1)
    success "Extension package created: $EXTENSION_PACKAGE ($package_size)"

    echo ""
    echo "Extension Package Usage:"
    echo "1. Transfer $EXTENSION_PACKAGE to player via DWS"
    echo "2. On player: mkdir -p /usr/local && cd /usr/local"
    echo "3. On player: unzip /storage/sd/$EXTENSION_PACKAGE"
    echo "4. On player: bash ./ext_npu_yolo_install-lvm.sh"
    echo "5. On player: reboot"
    echo "Note: Extension installation is permanent (persists across reboots)"
}

# Cleanup staging directory
cleanup_staging() {
    if [[ -d "staging" ]]; then
        log "Cleaning up staging directory..."
        rm -rf staging
        success "Staging directory cleaned up"
    fi
}

# Run validation if requested
run_validation() {
    if [[ "$VERIFY" == "true" ]]; then
        echo ""
        log "Running validation..."
        
        # Basic validation checks
        log "Validating package contents..."
        
        # Check if bsext_init can parse without errors
        if bash -n staging/bsext_init; then
            success "bsext_init syntax validation passed"
        else
            warn "bsext_init syntax validation failed"
        fi
        
        # Check for executable permissions
        if [[ -x staging/bsext_init ]]; then
            success "bsext_init is executable"
        else
            warn "bsext_init is not executable"
        fi
    fi
}

# Main packaging function
main() {
    echo "BrightSign YOLO Object Detection - Package Creation"
    echo "=================================================="
    
    # Show configuration
    echo "Configuration:"
    echo "  SOC Filter: ${SPECIFIC_SOC:-All supported SOCs}"
    echo "  Model Filter: $SPECIFIC_MODEL"
    echo "  Package Type: $([ "$DEV_ONLY" == "true" ] && echo "Development only" || [ "$EXT_ONLY" == "true" ] && echo "Extension only" || echo "Both")"
    echo ""

    local start_time=$(date +%s)

    check_prerequisites
    echo ""

    create_package_structure
    copy_binaries
    copy_models
    generate_manifest
    copy_extension_scripts
    echo ""

    enhanced_validation
    echo ""

    # Create packages based on options
    if [[ "$EXT_ONLY" == "true" ]]; then
        create_extension_package
    elif [[ "$DEV_ONLY" == "true" ]]; then
        create_development_package
    else
        create_development_package
        echo ""
        create_extension_package
    fi

    run_validation

    # Clean up staging directory after successful packaging
    cleanup_staging

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    echo ""
    success "Packaging completed in $(($duration / 60))m $(($duration % 60))s"

    # Show created packages
    echo ""
    echo "Created packages:"
    if [[ "$EXT_ONLY" != "true" ]]; then
        echo "  ðŸ“¦ $DEVELOPMENT_PACKAGE (development/testing)"
    fi
    if [[ "$DEV_ONLY" != "true" ]]; then
        echo "  ðŸ“¦ $EXTENSION_PACKAGE (production)"
    fi

    # Show what was packaged
    echo ""
    echo "Package contents:"
    for soc in "${!SOC_PLATFORMS[@]}"; do
        if [[ -n "$SPECIFIC_SOC" && "$SPECIFIC_SOC" != "$soc" ]]; then
            continue
        fi
        
        local platform="${SOC_PLATFORMS[$soc]}"
        echo "  ðŸŽ¯ $soc ($platform): Binary + Models ($SPECIFIC_MODEL)"
    done

    echo ""
    echo "Next steps:"
    echo "1. Transfer package(s) to BrightSign player"
    echo "2. Install using instructions shown above"
    echo "3. Configure via registry if needed (classes, confidence, etc.)"
    echo "4. Test with attached USB camera"
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi